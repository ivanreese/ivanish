<!-- @import ../../header.kit -->

<main id="starfield">
  <style>
    header.stars {
      background: none;
    }
    
    header.stars canvas {
      display: none;
    }
    
    header.stars div, header.stars div a, header.stars div a:visited {
      color: #33002A;
    }
    
    #starfield .stars canvas.js-stars {
      position: static;
      height: 500px;
    }
    
    main#starfield {
      padding-top: 4vh;
    }
    
  </style>
  
  <title>Starfield</title>
  
  <section class="hero">
    <a href="/toy/starfield-full">
      <div class="stars">
        <canvas class="js-stars"></canvas>
      </div>
    </a>
    <p>Click this preview to see a fullscreen version</p>
  </section>
  
  <section>
    <p>
      One of the very first goals for this website is that it should be blindingly fast to load.
    </p>
    <p>
      There are a handful of sites out there, James Hague's <a href="http://prog21.dadgum.com">Programming In The 21st Century</a> most of all, that are astoundingly quick.
      The common thrust among them is a return to a simpler form of web design: inline CSS, no JS, no images — in effect, 1 HTTP request per page.
      The challenge I gave myself was to see how close to that level of speed I could get, while still having a visually-rich website.
      My site has custom fonts, a fair bit of CSS, plenty of images, but it should still load with a small handful of HTTP requests in a medium handful of milliseconds anywhere in the world.
    </p>
    <p>
      For the home page of the site, I wanted a big splashy graphic.
      Of course, loading such a big graphic would miserably slow things down.
      It occurred to me that I could probably procedurally render something — the necessary JS would only be a few hundred bytes. The initial render could probably happen within a few milliseconds.
      But what could I render that would be visually captivating?
      The "star bar" at the top of <a href="http://socket.io">socket.io</a> has always stuck out in my mind as a super-simple, super-cool bit of web design.
      Stars are pretty simple — a dark background, some points of light, maybe a few cloudy color regions for that <a href="http://www.homeworldremastered.com">Homeworld</a> feel.
      Should be easy.
    </p>
    <p>
      After a bit of experimentation, I managed to create a screenfull of stars and nebulae-esq clouds that looked <em>almost</em> photographic.
      It loaded instantly, and rendered in ~40ms (depending on screen size — the complexity of the graphic is dynamic, so support a broad range of device profiles).
      Success!
    </p>
    <p>
      Then came optimization. Could I get that 40ms down to 20ms? Can I make it look as good on a dim monitor in daylight as on a bright monitor in the dark?
      Tweaks tweaks tweaks tweaks twea... and then I hit a bug. While optimizing the initial setup, I changed some code that was inadvertently resizing the buffer on each redraw, clearing the buffer.
      At the time, I was playing with moving the stars a bit based on the scroll position, for a fancy parallax effect that'd be impossible to do with static images (even multiple layers of static images, a la <a href="http://firewatchgame.com">Firewatch</a>).
      Suddenly, I had stars and low-opacity nebula colors sliding around, drawing again and again on top of the same buffer.
      And that was it! There's the high-impact splashy graphic I wanted for my home page.
      It loads faster than any image, renders super quick (with room for further optimization, natch), and is more striking and visceral than any static image.
    </p>
  </section>

  <section class="related">
    <a href="/code">Toy</a> from <a href="/year/2016">2016</a>.
  </section>
  
</main>
